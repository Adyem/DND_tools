Custom Memory Allocator (CMA) - Beta Version

This is a beta version of the Custom Memory Allocator (CMA). To use the CMA, simply add custom_allocator.cpp to the Makefile of your project. The CMA provides several functions to manage memory with criticality awareness, cleanup options, and allocation assurance.

Features

Custom Memory Allocation: Allocate memory blocks with control over their criticality.

Memory Cleanup: Clean up non-critical or all allocated memory blocks.

Memory Availability Assurance: Ensure that sufficient memory is available for future allocations.

Block Coalescing: Automatically merge adjacent free blocks to reduce fragmentation.

Page Management: Allocate and manage memory pages for efficient memory usage.

Valgrind Support (Optional): If using Valgrind for memory checking, set the DEBUG macro to 1. In debug mode, Valgrind will protect blocks that include the metadata of memory allocations, enhancing memory safety.

Function Overview

cma_malloc

void* cma_malloc(size_t size, bool critical);

Description

Allocates a memory block of the specified size. The critical flag indicates whether the memory is critical to the application's operation.

Parameters:

size: The size of the memory block to allocate (in bytes).

critical: A boolean flag indicating whether the memory is critical (true) or non-critical (false).

Returns: A pointer to the allocated memory block, or nullptr if the allocation fails.

Usage

void* ptr = cma_malloc(1024, false); // Allocate 1024 bytes of non-critical memory

cma_free

void cma_free(void* ptr);

Description

Frees a previously allocated memory block.

Parameters:

ptr: A pointer to the memory block to free.

Notes:

If ptr is nullptr, the function does nothing.

The function checks for invalid or double frees. It is the user's responsibility to ensure that no invalid or double frees occur, similar to how free in C and delete in C++ must be used correctly. The program will segfault upon any invalid or double frees occurring. This can happen due to memory corruption affecting the magic key that the cma_free function relies on due to buffer overflows or underflows, freeing a pointer that doesn't lie within any of the pages that have been allocated, or freeing a pointer that is not pointing to the start of a memory block.

Usage

cma_free(ptr); // Free the memory block pointed to by ptr

cma_cleanup_non_critical_memory

void cma_cleanup_non_critical_memory();

Description

Cleans up all non-critical memory blocks that have been freed. This function is useful for releasing memory that is no longer needed but was marked as non-critical.

Usage

cma_cleanup_non_critical_memory(); // Clean up non-critical memory

cma_cleanup_all_memory

void cma_cleanup_all_memory();

Description

Cleans up all allocated memory blocks, both critical and non-critical. This function should be called when the application is terminating or when all allocated memory is no longer needed.

Usage

cma_cleanup_all_memory(); // Clean up all memory

cma_ensure_memory_available

bool cma_ensure_memory_available(const size_t* sizes, size_t count, bool critical);

Description

Ensures that sufficient memory is available for future allocations. This function pre-allocates memory to satisfy the requested sizes.

Parameters:

sizes: An array of sizes representing future memory allocation requests.

count: The number of elements in the sizes array.

critical: A boolean flag indicating whether the memory to be ensured is critical.

Returns: true if memory was successfully ensured, or false if the allocation failed.

Usage

size_t future_sizes[] = {512, 256, 1024};
bool success = cma_ensure_memory_available(future_sizes, 3, false);

cma_add_page

bool cma_add_page(bool critical);

Description

Adds a new memory page to the allocator. This can be useful when you anticipate needing more memory and want to preemptively allocate it.

Parameters:

critical: A boolean flag indicating whether the new page should be marked as critical.

Returns: true if the page was successfully added, or false if the allocation failed.

Usage

bool success = cma_add_page(true); // Add a critical memory page

Usage Examples

Example 1: Basic Allocation and Deallocation

#include "cma.hpp"

int main() {
    // Allocate a block of 256 bytes of non-critical memory
    void* ptr = cma_malloc(256, false);
    if (ptr == nullptr) {
        std::cerr << "Allocation failed." << std::endl;
        return 1;
    }

    // Use the allocated memory...
    memset(ptr, 0, 256);

    // Free the memory when done
    cma_free(ptr);

    // Clean up non-critical memory
    cma_cleanup_non_critical_memory();

    return 0;
}

Example 2: Ensuring Memory Availability

#include "cma.hpp"

int main() {
    size_t future_allocations[] = {1024, 2048, 4096};

    // Ensure memory is available for future allocations
    if (!cma_ensure_memory_available(future_allocations, 3, false)) {
        std::cerr << "Failed to ensure memory availability." << std::endl;
        return 1;
    }

    // Proceed with allocations
    void* ptr1 = cma_malloc(1024, false);
    void* ptr2 = cma_malloc(2048, false);
    void* ptr3 = cma_malloc(4096, false);

    // Use the allocated memory...
    // ...

    // Free the memory
    cma_free(ptr1);
    cma_free(ptr2);
    cma_free(ptr3);

    // Clean up all memory
    cma_cleanup_all_memory();

    return 0;
}

Configuration Options

DEBUG Macro

The DEBUG macro controls whether the CMA enables Valgrind support for enhanced memory safety.

Usage: Define DEBUG to 1 to enable debug mode.

#define DEBUG 1
#include "cma.hpp"

Effects: In debug mode, Valgrind will protect blocks that include the metadata of memory allocations. This helps detect memory issues during development.

Limitations and Considerations

Thread Safety: The CMA is not thread-safe. If used in a multi-threaded application, you must provide your own synchronization mechanisms (e.g., mutexes) to protect shared data structures.

Memory Fragmentation: While the CMA attempts to reduce fragmentation by coalescing adjacent free blocks, fragmentation can still occur over time.

Error Handling: It is the user's responsibility to ensure no invalid or double frees occur, similar to how free in C and delete in C++ must be used correctly.

Alignment: Memory blocks are aligned to 8-byte boundaries by default.

Valgrind Support: If you are using Valgrind, the CMA includes calls to Valgrind macros to help detect memory issues. Set DEBUG to 1 to enable this feature.

License

The CMA code is provided "as is" without warranty of any kind. Use it at your own risk.

Conclusion

The Custom Memory Allocator provides a flexible way to manage memory in C++ applications, giving you control over allocation strategies and memory cleanup. By understanding and utilizing the functions provided by the CMA, you can optimize memory usage and improve the performance of your application.
