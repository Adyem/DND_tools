Custom Memory Allocator (CMA) - Beta Version

This is a beta version of the Custom Memory Allocator (CMA). To use the CMA, simply add custom_allocator.cpp to the Makefile of your project. The CMA provides several functions to manage memory with criticality awareness, cleanup options, and allocation assurance.

Features

    Custom Memory Allocation: Allocate memory blocks with control over their criticality.
    Memory Cleanup: Clean up non-critical or all allocated memory blocks.
    Memory Availability Assurance: Ensure that sufficient memory is available for future allocations.
    Optional Bypass Mode: Bypass the custom allocator for debugging or development purposes.
    Block Coalescing: Automatically merge adjacent free blocks to reduce fragmentation.
    Page Management: Allocate and manage memory pages for efficient memory usage.
    Valgrind Support (Optional): If using Valgrind for memory checking, include the Valgrind headers 
    and make the necessary calls. The CMA code includes optional Valgrind support.

Function Overview
cma_malloc

void* cma_malloc(size_t size, bool critical);

Description

Allocates a memory block of the specified size. The critical flag indicates whether the memory is critical to the application's operation.

    Parameters:
        size: The size of the memory block to allocate (in bytes).
        critical: A boolean flag indicating whether the memory is critical (true) or non-critical (false).

    Returns: A pointer to the allocated memory block, or nullptr if the allocation fails.

Usage

void* ptr = cma_malloc(1024, false); // Allocate 1024 bytes of non-critical memory

cma_free

void cma_free(void* ptr);

Description

Frees a previously allocated memory block.

    Parameters:
        ptr: A pointer to the memory block to free.

    Notes:
        If ptr is nullptr, the function does nothing.
        The function checks for invalid or double frees and segfaults the program if detected.

Usage

cma_free(ptr); // Free the memory block pointed to by ptr

cma_cleanup_non_critical_memory

void cma_cleanup_non_critical_memory();

Description

Cleans up all non-critical memory blocks that have been freed. This function is useful for releasing memory that is no longer needed but was marked as non-critical.
Usage

cma_cleanup_non_critical_memory(); // Clean up non-critical memory

cma_cleanup_all_memory

void cma_cleanup_all_memory();

Description

Cleans up all allocated memory blocks, both critical and non-critical. This function should be called when the application is terminating or when all allocated memory is no longer needed.
Usage

cma_cleanup_all_memory(); // Clean up all memory

cma_ensure_memory_available

bool cma_ensure_memory_available(const size_t* sizes, size_t count, bool critical);

Description

Ensures that sufficient memory is available for future allocations. This function pre-allocates memory to satisfy the requested sizes.

    Parameters:
        sizes: An array of sizes representing future memory allocation requests.
        count: The number of elements in the sizes array.
        critical: A boolean flag indicating whether the memory to be ensured is critical.

    Returns: true if memory was successfully ensured, or false if the allocation failed.

Usage

size_t future_sizes[] = {512, 256, 1024};
bool success = cma_ensure_memory_available(future_sizes, 3, false);

cma_add_page

bool cma_add_page(bool critical);

Description

Adds a new memory page to the allocator. This can be useful when you anticipate needing more memory and want to preemptively allocate it.

    Parameters:
        critical: A boolean flag indicating whether the new page should be marked as critical.

    Returns: true if the page was successfully added, or false if the allocation failed.

Usage

bool success = cma_add_page(true); // Add a critical memory page

Usage Examples
Example 1: Basic Allocation and Deallocation

#include "cma.hpp"

int main() {
    // Allocate a block of 256 bytes of non-critical memory
    void* ptr = cma_malloc(256, false);
    if (ptr == nullptr) {
        std::cerr << "Allocation failed." << std::endl;
        return 1;
    }

    // Use the allocated memory...
    memset(ptr, 0, 256);

    // Free the memory when done
    cma_free(ptr);

    // Clean up non-critical memory
    cma_cleanup_non_critical_memory();

    return 0;
}

Example 2: Ensuring Memory Availability

cpp

#include "cma.hpp"

int main() {
    size_t future_allocations[] = {1024, 2048, 4096};

    // Ensure memory is available for future allocations
    if (!cma_ensure_memory_available(future_allocations, 3, false)) {
        std::cerr << "Failed to ensure memory availability." << std::endl;
        return 1;
    }

    // Proceed with allocations
    void* ptr1 = cma_malloc(1024, false);
    void* ptr2 = cma_malloc(2048, false);
    void* ptr3 = cma_malloc(4096, false);

    // Use the allocated memory...
    // ...

    // Free the memory
    cma_free(ptr1);
    cma_free(ptr2);
    cma_free(ptr3);

    // Clean up all memory
    cma_cleanup_all_memory();

    return 0;
}

Configuration Options
BYPASS_ALLOC Macro

The BYPASS_ALLOC macro controls whether the CMA uses the custom allocation strategy or a simplified version that bypasses some features.

    Usage: Define BYPASS_ALLOC to 1 to enable bypass mode.

#define BYPASS_ALLOC 1
#include "cma.hpp"

    Effects:
        In bypass mode, the CMA uses a simpler allocation strategy, mainly for debugging or development purposes.
        Functions related to page management are not applicable in bypass mode.

Limitations and Considerations

    Thread Safety: The CMA is not thread-safe. If used in a multi-threaded application, you must provide your own synchronization mechanisms (e.g., mutexes) to protect shared data structures.
    Memory Fragmentation: While the CMA attempts to reduce fragmentation by coalescing adjacent free blocks, fragmentation can still occur over time.
    Error Handling: The CMA uses abort() when detecting critical errors such as invalid or double frees. Ensure that your application handles such scenarios appropriately.
    Alignment: Memory blocks are aligned to 8-byte boundaries by default.
    Valgrind Support: If you are using Valgrind, the CMA includes calls to Valgrind macros to help detect memory issues.

License

The CMA code is provided "as is" without warranty of any kind. Use it at your own risk.
Conclusion

The Custom Memory Allocator provides a flexible way to manage memory in C++ applications, giving you control over allocation strategies and memory cleanup. By understanding and utilizing the functions provided by the CMA, you can optimize memory usage and improve the performance of your application.

If you have any questions or need further assistance, please reach out to the maintainer.
